<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UML-диаграмма классов</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            display: flex;
            height: 90vh;
            gap: 10px;
        }
        
        .toolbox {
            width: 200px;
            background-color: white;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .toolbox h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .toolbox button {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .toolbox button:hover {
            background-color: #385d8a;
        }
        
        .canvas-container {
            flex: 1;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        #uml-canvas {
            width: 100%;
            height: 100%;
            background-color: white;
            cursor: default;
        }
        
        .uml-class {
            position: absolute;
            min-width: 200px;
            background-color: white;
            border: 1px solid #333;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: move;
            user-select: none;
        }
        
        .class-header {
            background-color: #e6e6e6;
            padding: 8px;
            border-bottom: 1px solid #333;
            font-weight: bold;
            text-align: center;
        }
        
        .class-body {
            padding: 8px;
        }
        
        .class-attributes, .class-methods {
            margin-bottom: 8px;
        }
        
        .interface {
            border-style: dashed;
        }
        
        .abstract {
            font-style: italic;
        }
        
        .selected {
            border: 2px solid #4a6fa5;
            box-shadow: 0 0 5px rgba(74, 111, 165, 0.5);
        }
        
        .connection-point {
            width: 8px;
            height: 8px;
            background-color: #4a6fa5;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
        }
        
        .connection-line {
            stroke: #333;
            stroke-width: 2;
            fill: none;
        }
        
        .inheritance-arrow {
            fill: #333;
        }
        
        .composition-arrow {
            fill: #333;
        }
        
        .association-line {
            stroke-dasharray: 5, 5;
        }
        
        .legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>UML-диаграмма классов: Система управления заказами</h1>
    
    <div class="container">
        <div class="toolbox">
            <h3>Элементы</h3>
            <button id="add-class">Добавить класс</button>
            <button id="add-interface">Добавить интерфейс</button>
            <button id="add-package">Добавить пакет</button>
            <button id="add-note">Добавить примечание</button>
            
            <h3>Связи</h3>
            <button id="add-inheritance">Наследование</button>
            <button id="add-association">Ассоциация</button>
            <button id="add-aggregation">Агрегация</button>
            <button id="add-composition">Композиция</button>
            <button id="add-implementation">Реализация</button>
            
            <h3>Действия</h3>
            <button id="delete-element">Удалить элемент</button>
            <button id="clear-canvas">Очистить холст</button>
            <button id="export-png">Экспорт в PNG</button>
        </div>
        
        <div class="canvas-container">
            <svg id="uml-canvas"></svg>
            <div class="legend">
                <div><strong>Легенда:</strong></div>
                <div>+ public</div>
                <div>- private</div>
                <div># protected</div>
                <div><em>курсив - абстрактный</em></div>
                <div>--- реализация</div>
            </div>
        </div>
    </div>

    <script>
        // Состояние приложения
        const state = {
            elements: [],
            connections: [],
            selectedElement: null,
            currentMode: 'select',
            tempConnection: null,
            connectionStart: null
        };

        // DOM элементы
        const canvas = document.getElementById('uml-canvas');
        const addClassBtn = document.getElementById('add-class');
        const addInterfaceBtn = document.getElementById('add-interface');
        const addInheritanceBtn = document.getElementById('add-inheritance');
        const addAssociationBtn = document.getElementById('add-association');
        const addAggregationBtn = document.getElementById('add-aggregation');
        const addCompositionBtn = document.getElementById('add-composition');
        const addImplementationBtn = document.getElementById('add-implementation');
        const deleteElementBtn = document.getElementById('delete-element');
        const clearCanvasBtn = document.getElementById('clear-canvas');
        const exportPngBtn = document.getElementById('export-png');

        // Инициализация холста
        function initCanvas() {
            // Установка размеров SVG
            updateCanvasSize();
            
            // Обработчики событий
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            
            // Обработчики кнопок
            addClassBtn.addEventListener('click', () => {
                state.currentMode = 'add-class';
                createUmlClass('НовыйКласс', 100, 100);
            });
            
            addInterfaceBtn.addEventListener('click', () => {
                state.currentMode = 'add-interface';
                createUmlInterface('IИнтерфейс', 100, 100);
            });
            
            addInheritanceBtn.addEventListener('click', () => {
                state.currentMode = 'inheritance';
            });
            
            addAssociationBtn.addEventListener('click', () => {
                state.currentMode = 'association';
            });
            
            addAggregationBtn.addEventListener('click', () => {
                state.currentMode = 'aggregation';
            });
            
            addCompositionBtn.addEventListener('click', () => {
                state.currentMode = 'composition';
            });
            
            addImplementationBtn.addEventListener('click', () => {
                state.currentMode = 'implementation';
            });
            
            deleteElementBtn.addEventListener('click', deleteSelectedElement);
            clearCanvasBtn.addEventListener('click', clearCanvas);
            exportPngBtn.addEventListener('click', exportToPng);
            
            // Создание примера UML-диаграммы
            createExampleDiagram();
        }

        // Обновление размера холста
        function updateCanvasSize() {
            const container = canvas.parentElement;
            canvas.setAttribute('width', container.clientWidth);
            canvas.setAttribute('height', container.clientHeight);
        }

        // Создание UML класса
        function createUmlClass(name, x, y) {
            const classId = 'class-' + Date.now();
            const classElement = document.createElement('div');
            classElement.id = classId;
            classElement.className = 'uml-class';
            classElement.style.left = x + 'px';
            classElement.style.top = y + 'px';
            
            classElement.innerHTML = `
                <div class="class-header">${name}</div>
                <div class="class-body">
                    <div class="class-attributes">
                        <div>+ id: int</div>
                        <div>+ имя: string</div>
                    </div>
                    <div class="class-methods">
                        <div>+ создать()</div>
                        <div>+ удалить()</div>
                    </div>
                </div>
            `;
            
            canvas.parentElement.appendChild(classElement);
            
            // Добавление точек соединения
            addConnectionPoints(classElement);
            
            // Добавление в состояние
            state.elements.push({
                id: classId,
                type: 'class',
                name: name,
                element: classElement,
                x: x,
                y: y
            });
            
            // Обработчики событий для элемента
            makeElementDraggable(classElement);
            
            return classElement;
        }

        // Создание UML интерфейса
        function createUmlInterface(name, x, y) {
            const interfaceId = 'interface-' + Date.now();
            const interfaceElement = document.createElement('div');
            interfaceElement.id = interfaceId;
            interfaceElement.className = 'uml-class interface';
            interfaceElement.style.left = x + 'px';
            interfaceElement.style.top = y + 'px';
            
            interfaceElement.innerHTML = `
                <div class="class-header">&lt;&lt;interface&gt;&gt;<br>${name}</div>
                <div class="class-body">
                    <div class="class-methods">
                        <div>+ войти()</div>
                        <div>+ выйти()</div>
                    </div>
                </div>
            `;
            
            canvas.parentElement.appendChild(interfaceElement);
            
            // Добавление точек соединения
            addConnectionPoints(interfaceElement);
            
            // Добавление в состояние
            state.elements.push({
                id: interfaceId,
                type: 'interface',
                name: name,
                element: interfaceElement,
                x: x,
                y: y
            });
            
            // Обработчики событий для элемента
            makeElementDraggable(interfaceElement);
            
            return interfaceElement;
        }

        // Создание точек соединения для элемента
        function addConnectionPoints(element) {
            const rect = element.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();
            
            // Точки соединения по сторонам элемента
            const sides = ['top', 'right', 'bottom', 'left'];
            
            sides.forEach(side => {
                const point = document.createElement('div');
                point.className = 'connection-point';
                
                // Позиционирование точки
                let left, top;
                switch(side) {
                    case 'top':
                        left = rect.width / 2 - 4;
                        top = -4;
                        break;
                    case 'right':
                        left = rect.width - 4;
                        top = rect.height / 2 - 4;
                        break;
                    case 'bottom':
                        left = rect.width / 2 - 4;
                        top = rect.height - 4;
                        break;
                    case 'left':
                        left = -4;
                        top = rect.height / 2 - 4;
                        break;
                }
                
                point.style.left = left + 'px';
                point.style.top = top + 'px';
                
                // Обработчик события для точки соединения
                point.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(element, point, side);
                });
                
                element.appendChild(point);
            });
        }

        // Начало создания связи
        function startConnection(element, point, side) {
            const rect = element.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();
            
            // Вычисление начальной точки
            let startX, startY;
            switch(side) {
                case 'top':
                    startX = rect.left - containerRect.left + rect.width / 2;
                    startY = rect.top - containerRect.top;
                    break;
                case 'right':
                    startX = rect.left - containerRect.left + rect.width;
                    startY = rect.top - containerRect.top + rect.height / 2;
                    break;
                case 'bottom':
                    startX = rect.left - containerRect.left + rect.width / 2;
                    startY = rect.top - containerRect.top + rect.height;
                    break;
                case 'left':
                    startX = rect.left - containerRect.left;
                    startY = rect.top - containerRect.top + rect.height / 2;
                    break;
            }
            
            state.connectionStart = {
                element: element,
                point: point,
                side: side,
                x: startX,
                y: startY
            };
            
            // Создание временной линии
            state.tempConnection = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            state.tempConnection.setAttribute('x1', startX);
            state.tempConnection.setAttribute('y1', startY);
            state.tempConnection.setAttribute('x2', startX);
            state.tempConnection.setAttribute('y2', startY);
            state.tempConnection.setAttribute('class', 'connection-line');
            
            canvas.appendChild(state.tempConnection);
        }

        // Создание перетаскиваемого элемента
        function makeElementDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;
            
            element.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('connection-point')) {
                    return;
                }
                
                isDragging = true;
                offsetX = e.clientX - element.getBoundingClientRect().left;
                offsetY = e.clientY - element.getBoundingClientRect().top;
                
                // Выделение элемента
                selectElement(element);
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const containerRect = canvas.parentElement.getBoundingClientRect();
                const x = e.clientX - containerRect.left - offsetX;
                const y = e.clientY - containerRect.top - offsetY;
                
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                
                // Обновление позиции в состоянии
                const elementData = state.elements.find(el => el.element === element);
                if (elementData) {
                    elementData.x = x;
                    elementData.y = y;
                }
                
                // Обновление связанных линий
                updateConnections(element);
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Выбор элемента
        function selectElement(element) {
            // Снятие выделения со всех элементов
            state.elements.forEach(el => {
                el.element.classList.remove('selected');
            });
            
            // Выделение выбранного элемента
            element.classList.add('selected');
            state.selectedElement = element;
        }

        // Удаление выбранного элемента
        function deleteSelectedElement() {
            if (!state.selectedElement) return;
            
            // Удаление из DOM
            state.selectedElement.remove();
            
            // Удаление из состояния
            state.elements = state.elements.filter(el => el.element !== state.selectedElement);
            
            // Удаление связанных соединений
            state.connections = state.connections.filter(conn => {
                if (conn.from.element === state.selectedElement || conn.to.element === state.selectedElement) {
                    // Удаление линии из SVG
                    if (conn.line && conn.line.parentNode) {
                        conn.line.parentNode.removeChild(conn.line);
                    }
                    return false;
                }
                return true;
            });
            
            state.selectedElement = null;
        }

        // Очистка холста
        function clearCanvas() {
            // Удаление всех элементов
            state.elements.forEach(el => {
                el.element.remove();
            });
            
            // Удаление всех соединений
            state.connections.forEach(conn => {
                if (conn.line && conn.line.parentNode) {
                    conn.line.parentNode.removeChild(conn.line);
                }
            });
            
            // Очистка состояния
            state.elements = [];
            state.connections = [];
            state.selectedElement = null;
        }

        // Экспорт в PNG
        function exportToPng() {
            alert('Экспорт в PNG будет реализован в полной версии приложения');
            // В реальном приложении здесь будет код для преобразования SVG в PNG
        }

        // Обновление соединений при перемещении элемента
        function updateConnections(element) {
            state.connections.forEach(conn => {
                if (conn.from.element === element || conn.to.element === element) {
                    updateConnectionLine(conn);
                }
            });
        }

        // Обновление линии соединения
        function updateConnectionLine(connection) {
            const fromRect = connection.from.element.getBoundingClientRect();
            const toRect = connection.to.element.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();
            
            // Вычисление точек соединения
            const fromPoint = calculateConnectionPoint(fromRect, containerRect, connection.from.side);
            const toPoint = calculateConnectionPoint(toRect, containerRect, connection.to.side);
            
            // Обновление линии
            connection.line.setAttribute('x1', fromPoint.x);
            connection.line.setAttribute('y1', fromPoint.y);
            connection.line.setAttribute('x2', toPoint.x);
            connection.line.setAttribute('y2', toPoint.y);
        }

        // Вычисление точки соединения
        function calculateConnectionPoint(elementRect, containerRect, side) {
            let x, y;
            
            switch(side) {
                case 'top':
                    x = elementRect.left - containerRect.left + elementRect.width / 2;
                    y = elementRect.top - containerRect.top;
                    break;
                case 'right':
                    x = elementRect.left - containerRect.left + elementRect.width;
                    y = elementRect.top - containerRect.top + elementRect.height / 2;
                    break;
                case 'bottom':
                    x = elementRect.left - containerRect.left + elementRect.width / 2;
                    y = elementRect.top - containerRect.top + elementRect.height;
                    break;
                case 'left':
                    x = elementRect.left - containerRect.left;
                    y = elementRect.top - containerRect.top + elementRect.height / 2;
                    break;
            }
            
            return { x, y };
        }

        // Обработчики событий холста
        function handleCanvasMouseDown(e) {
            // Реализация будет добавлена в полной версии
        }

        function handleCanvasMouseMove(e) {
            // Обновление временной линии при создании соединения
            if (state.tempConnection && state.connectionStart) {
                const containerRect = canvas.parentElement.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const y = e.clientY - containerRect.top;
                
                state.tempConnection.setAttribute('x2', x);
                state.tempConnection.setAttribute('y2', y);
            }
        }

        function handleCanvasMouseUp(e) {
            // Завершение создания соединения
            if (state.tempConnection && state.connectionStart) {
                // Находим элемент под курсором
                const elementsUnderCursor = document.elementsFromPoint(e.clientX, e.clientY);
                const targetElement = elementsUnderCursor.find(el => 
                    el.classList.contains('uml-class') && 
                    el !== state.connectionStart.element
                );
                
                if (targetElement) {
                    // Находим ближайшую точку соединения
                    const targetPoints = targetElement.querySelectorAll('.connection-point');
                    let closestPoint = null;
                    let minDistance = Infinity;
                    
                    targetPoints.forEach(point => {
                        const pointRect = point.getBoundingClientRect();
                        const containerRect = canvas.parentElement.getBoundingClientRect();
                        const pointX = pointRect.left - containerRect.left + pointRect.width / 2;
                        const pointY = pointRect.top - containerRect.top + pointRect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - containerRect.left - pointX, 2) + 
                            Math.pow(e.clientY - containerRect.top - pointY, 2)
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPoint = point;
                        }
                    });
                    
                    if (closestPoint) {
                        // Определяем сторону целевого элемента
                        let targetSide;
                        const pointRect = closestPoint.getBoundingClientRect();
                        const elementRect = targetElement.getBoundingClientRect();
                        
                        if (Math.abs(pointRect.top - elementRect.top) < 5) targetSide = 'top';
                        else if (Math.abs(pointRect.bottom - elementRect.bottom) < 5) targetSide = 'bottom';
                        else if (Math.abs(pointRect.left - elementRect.left) < 5) targetSide = 'left';
                        else if (Math.abs(pointRect.right - elementRect.right) < 5) targetSide = 'right';
                        
                        // Создаем постоянное соединение
                        createConnection(
                            state.connectionStart.element,
                            state.connectionStart.side,
                            targetElement,
                            targetSide,
                            state.currentMode
                        );
                    }
                }
                
                // Удаляем временную линию
                canvas.removeChild(state.tempConnection);
                state.tempConnection = null;
                state.connectionStart = null;
            }
        }

        // Создание соединения между элементами
        function createConnection(fromElement, fromSide, toElement, toSide, type) {
            const fromRect = fromElement.getBoundingClientRect();
            const toRect = toElement.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();
            
            // Вычисление точек соединения
            const fromPoint = calculateConnectionPoint(fromRect, containerRect, fromSide);
            const toPoint = calculateConnectionPoint(toRect, containerRect, toSide);
            
            // Создание линии
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPoint.x);
            line.setAttribute('y1', fromPoint.y);
            line.setAttribute('x2', toPoint.x);
            line.setAttribute('y2', toPoint.y);
            
            // Настройка стиля линии в зависимости от типа связи
            let lineClass = 'connection-line';
            switch(type) {
                case 'inheritance':
                    // Добавление стрелки наследования
                    addInheritanceArrow(line, toPoint.x, toPoint.y, toSide);
                    break;
                case 'association':
                    lineClass += ' association-line';
                    break;
                case 'aggregation':
                    // Добавление ромба агрегации
                    addAggregationDiamond(line, fromPoint.x, fromPoint.y, fromSide);
                    break;
                case 'composition':
                    // Добавление закрашенного ромба композиции
                    addCompositionDiamond(line, fromPoint.x, fromPoint.y, fromSide);
                    break;
                case 'implementation':
                    lineClass += ' association-line';
                    break;
            }
            
            line.setAttribute('class', lineClass);
            canvas.appendChild(line);
            
            // Добавление в состояние
            state.connections.push({
                from: {
                    element: fromElement,
                    side: fromSide
                },
                to: {
                    element: toElement,
                    side: toSide
                },
                type: type,
                line: line
            });
        }

        // Добавление стрелки наследования
        function addInheritanceArrow(line, x, y, side) {
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            
            // Настройка положения стрелки в зависимости от стороны
            let points;
            switch(side) {
                case 'top':
                    points = `${x},${y} ${x-7},${y+10} ${x+7},${y+10}`;
                    break;
                case 'right':
                    points = `${x},${y} ${x-10},${y-7} ${x-10},${y+7}`;
                    break;
                case 'bottom':
                    points = `${x},${y} ${x-7},${y-10} ${x+7},${y-10}`;
                    break;
                case 'left':
                    points = `${x},${y} ${x+10},${y-7} ${x+10},${y+7}`;
                    break;
            }
            
            arrow.setAttribute('points', points);
            arrow.setAttribute('class', 'inheritance-arrow');
            canvas.appendChild(arrow);
        }

        // Добавление ромба агрегации
        function addAggregationDiamond(line, x, y, side) {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            
            // Настройка положения ромба в зависимости от стороны
            let points;
            switch(side) {
                case 'top':
                    points = `${x},${y} ${x-7},${y-10} ${x},${y-20} ${x+7},${y-10}`;
                    break;
                case 'right':
                    points = `${x},${y} ${x+10},${y-7} ${x+20},${y} ${x+10},${y+7}`;
                    break;
                case 'bottom':
                    points = `${x},${y} ${x-7},${y+10} ${x},${y+20} ${x+7},${y+10}`;
                    break;
                case 'left':
                    points = `${x},${y} ${x-10},${y-7} ${x-20},${y} ${x-10},${y+7}`;
                    break;
            }
            
            diamond.setAttribute('points', points);
            diamond.setAttribute('class', 'connection-line');
            diamond.setAttribute('fill', 'white');
            canvas.appendChild(diamond);
        }

        // Добавление ромба композиции
        function addCompositionDiamond(line, x, y, side) {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            
            // Настройка положения ромба в зависимости от стороны
            let points;
            switch(side) {
                case 'top':
                    points = `${x},${y} ${x-7},${y-10} ${x},${y-20} ${x+7},${y-10}`;
                    break;
                case 'right':
                    points = `${x},${y} ${x+10},${y-7} ${x+20},${y} ${x+10},${y+7}`;
                    break;
                case 'bottom':
                    points = `${x},${y} ${x-7},${y+10} ${x},${y+20} ${x+7},${y+10}`;
                    break;
                case 'left':
                    points = `${x},${y} ${x-10},${y-7} ${x-20},${y} ${x-10},${y+7}`;
                    break;
            }
            
            diamond.setAttribute('points', points);
            diamond.setAttribute('class', 'composition-arrow');
            canvas.appendChild(diamond);
        }

        // Создание примера UML-диаграммы
        function createExampleDiagram() {
            // Создание классов согласно заданиям
            const userClass = createUmlClass('Пользователь', 50, 50);
            const clientClass = createUmlClass('Клиент', 50, 200);
            const adminClass = createUmlClass('Администратор', 50, 350);
            const productClass = createUmlClass('Товар', 300, 50);
            const orderClass = createUmlClass('Заказ', 300, 200);
            const entityClass = createUmlClass('Сущность', 550, 50);
            const databaseClass = createUmlClass('БазаДанных', 550, 200);
            const authInterface = createUmlInterface('IАвторизация', 550, 350);
            
            // Настройка специальных классов
            entityClass.querySelector('.class-header').classList.add('abstract');
            entityClass.querySelector('.class-methods').innerHTML = `
                <div class="abstract">+ создать()</div>
                <div class="abstract">+ удалить()</div>
            `;
            
            // Создание связей
            createConnection(clientClass, 'top', userClass, 'bottom', 'inheritance');
            createConnection(adminClass, 'top', userClass, 'bottom', 'inheritance');
            createConnection(userClass, 'right', orderClass, 'left', 'association');
            createConnection(orderClass, 'right', productClass, 'left', 'composition');
            createConnection(userClass, 'right', authInterface, 'left', 'implementation');
            createConnection(databaseClass, 'left', orderClass, 'right', 'association');
            createConnection(userClass, 'right', entityClass, 'left', 'inheritance');
            createConnection(productClass, 'right', entityClass, 'left', 'inheritance');
            createConnection(orderClass, 'right', entityClass, 'left', 'inheritance');
        }

        // Инициализация приложения
        window.addEventListener('load', initCanvas);
        window.addEventListener('resize', updateCanvasSize);
    </script>
</body>
</html>